<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>SlackTranslator</title>
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    /* Estilos para mensagens em processo de envio/tradu√ß√£o */
    .message.draft {
      background-color: #f8fbf8;
      border-left: 3px solid #5cb85c;
      border-radius: 4px;
      opacity: 0.9;
      margin-bottom: 12px;
    }
    
    .message.draft .message-author {
      color: #2c662d;
      font-weight: bold;
      font-style: italic;
    }
    
    .message.draft .message-content::before {
      content: "Enviando: ";
      color: #5cb85c;
      font-style: italic;
      font-weight: 500;
    }
    
    .message-header {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    
    .user-avatar {
      width: 36px;
      height: 36px;
      border-radius: 4px;
      margin-right: 8px;
    }
    
    .message-author {
      font-weight: bold;
      margin-right: 8px;
    }
    
    .message-time {
      font-size: 12px;
      color: #616061;
    }
    
    .message-content {
      margin-left: 44px;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <h1>SlackTranslator</h1>
  <div id="container">
    <div id="originals" class="column">
      <h2>Original Messages</h2>
      <ul id="original-messages"></ul>
    </div>
    <div id="translations" class="column">
      <h2>Translated Messages</h2>
      <ul id="translated-messages"></ul>
    </div>
  </div>

  <script>
    console.log('Iniciando aplicativo SlackTranslator...');
    
    const origList = document.getElementById('original-messages');
    const transList = document.getElementById('translated-messages');
    
    // Array de perfis aleat√≥rios para simular diferentes usu√°rios
    const userProfiles = [
      { name: 'Alex Wong', avatar: 'https://i.pravatar.cc/100?img=3' },
      { name: 'John Smith', avatar: 'https://i.pravatar.cc/100?img=5' },
      { name: 'Sarah Johnson', avatar: 'https://i.pravatar.cc/100?img=9' },
      { name: 'Maria Garcia', avatar: 'https://i.pravatar.cc/100?img=10' }
    ];
    
    // Armazenar informa√ß√µes do usu√°rio atual (voc√™) para identifica√ß√£o correta das mensagens
    let myUserInfo = { userId: '', name: '', avatar: '' };
    let userCache = {}; // Cache para armazenar informa√ß√µes dos usu√°rios j√° vistos
    let userInfoLoaded = false; // Flag para controlar se j√° carregamos as informa√ß√µes do usu√°rio
    
    // IMPORTANTE: Fun√ß√£o para obter e garantir que temos o ID do usu√°rio atual
    // Esta fun√ß√£o retorna uma Promise que s√≥ ser√° resolvida quando tivermos o ID
    async function ensureCurrentUserInfo() {
      if (userInfoLoaded && myUserInfo.userId) {
        console.log('‚òëÔ∏è Usando informa√ß√µes de usu√°rio j√° carregadas:', myUserInfo.userId);
        return myUserInfo;
      }
      
      console.log('‚ö†Ô∏è IMPORTANTE: Buscando informa√ß√µes do usu√°rio autenticado...');
      
      try {
        // Tentar at√© 3 vezes para garantir que conseguimos obter o ID
        for (let attempt = 1; attempt <= 3; attempt++) {
          console.log(`Tentativa ${attempt} de obter ID de usu√°rio...`);
          
          const response = await fetch('/current-user-info');
          const data = await response.json();
          
          if (data.user_id && data.user_id.trim() !== '') {
            myUserInfo.userId = data.user_id.trim();
            myUserInfo.name = data.username || 'You';
            myUserInfo.avatar = data.user_image;
            
            console.log('‚úÖ ID DE USU√ÅRIO CARREGADO COM SUCESSO:', myUserInfo.userId);
            
            // Armazenar suas informa√ß√µes no cache de usu√°rios
            userCache[myUserInfo.userId] = {
              name: 'You', // Sempre mostra "You" para o usu√°rio atual
              avatar: myUserInfo.avatar,
              id: myUserInfo.userId
            };
            
            userInfoLoaded = true;
            return myUserInfo;
          }
          
          // Se n√£o conseguimos o ID, esperar 500ms antes de tentar novamente
          if (attempt < 3) {
            console.warn(`ID de usu√°rio n√£o dispon√≠vel na tentativa ${attempt}, aguardando...`);
            await new Promise(resolve => setTimeout(resolve, 500));
          }
        }
        
        console.error('‚ùå FALHA CR√çTICA: N√£o foi poss√≠vel obter o ID do usu√°rio ap√≥s 3 tentativas!');
        return null;
      } catch (e) {
        console.error('‚ùå Erro ao buscar informa√ß√µes do usu√°rio:', e);
        return null;
      }
    }
    
    // Carregar informa√ß√µes do usu√°rio assim que a p√°gina iniciar
    window.addEventListener('DOMContentLoaded', () => {
      ensureCurrentUserInfo();
    });
    
    // Fun√ß√£o para buscar o ID do usu√°rio atual diretamente do servidor
    async function fetchCurrentUserInfo() {
      try {
        console.log('Buscando informa√ß√µes do usu√°rio atual...');
        const response = await fetch('/current-user-info');
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.user_id) {
            myUserInfo.userId = data.user_id;
            myUserInfo.name = data.username || 'You';
            myUserInfo.avatar = data.user_image;
            
            console.log('IMPORTANTE: ID do usu√°rio atual (voc√™) obtido com sucesso:', myUserInfo.userId);
            console.log('Suas informa√ß√µes de usu√°rio:', myUserInfo);
            return true;
          } else {
            console.warn('API retornou resposta OK mas sem ID de usu√°rio.');
          }
        } else {
          console.warn('Falha ao buscar informa√ß√µes do usu√°rio atual:', response.status);
        }
      } catch (error) {
        console.error('Erro ao buscar informa√ß√µes do usu√°rio atual:', error);
      }
      
      return false;
    }

    function formatTimestamp(timestamp) {
      if (!timestamp) timestamp = Date.now();
      
      const date = new Date(timestamp);
      const now = new Date();
      const yesterdayDate = new Date(now);
      yesterdayDate.setDate(now.getDate() - 1);
      
      // Formato para hora - 1:15 PM
      const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
      
      // Se for hoje ou ontem, mostrar isso em vez da data
      if (date.toDateString() === now.toDateString()) {
        return timeStr;
      } else if (date.toDateString() === yesterdayDate.toDateString()) {
        return 'yesterday ' + timeStr;
      } else {
        // Se for mais antigo, mostrar data abreviada
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + timeStr;
      }
    }
    
    // Acompanhamento da √∫ltima pessoa a enviar mensagem para cria√ß√£o de mensagens sequenciais
    let lastSender = { originalId: null, translatedId: null, original: null, translated: null };
    
    function addMessage(original, translation, sentByUser = false, timestamp = Date.now(), userData = null) {
      console.log('Adicionando nova mensagem:', original);
      
      // Determinar usu√°rio para a mensagem
      let user;
      console.log('userData recebido:', userData);
      
      // NOVA ABORDAGEM ROBUSTA: Agora temos seu ID de usu√°rio real do endpoint /current-user-info
      // Isso torna a detec√ß√£o muito mais confi√°vel e n√£o depende da ordem das mensagens
      
      // SOLU√á√ÉO FINAL: Usar os NOMES REAIS dos usu√°rios e n√£o mais "You"
      // Mesmo que os IDs estejam repetidos, os nomes de usu√°rio est√£o corretos

      // USAR UMA COMBINA√á√ÉO DE USERNAME + ID COMO IDENTIFICADOR √öNICO
      // Isso resolve o problema de IDs duplicados no backend
      if (userData && userData.username) {
        // Criar um ID composto √∫nico usando nome + ID real
        const uniqueId = `${userData.username}_${userData.user_id || Date.now()}`;
        console.log(`üîë Criando identificador √∫nico: '${uniqueId}'`);
        
        // Verificar cache com identificador √∫nico baseado no nome + ID
        const cachedUser = userCache[uniqueId];
        if (cachedUser) {
          console.log('‚ÑπÔ∏è Reusando usu√°rio em cache:', userData.username);
          user = {...cachedUser}; // Clone para seguran√ßa
        } else {
          // Novo usu√°rio ou n√£o encontrado no cache
          console.log('üÜï Processando usu√°rio:', userData.username);
          
          user = {
            // CORRE√á√ÉO FINAL: SEMPRE mostrar o nome real do remetente, NUNCA "You"
            name: userData.username || 'Unknown User', // Nome real diretamente do Slack
            avatar: userData.user_image || `https://ui-avatars.com/api/?name=${encodeURIComponent(userData.username || 'U')}&background=random`,
            id: uniqueId // ID √∫nico para agrupamento correto
          };
          
          // Armazenar no cache com o ID composto
          userCache[uniqueId] = {...user};
          console.log('üíæ Novo usu√°rio salvo com identificador √∫nico:', uniqueId);
        }
      } else {
      // Se n√£o temos dados do usu√°rio, usar fallback
      const randomProfile = userProfiles[Math.floor(Math.random() * userProfiles.length)];
      user = {
        name: randomProfile.name,
        avatar: randomProfile.avatar,
        id: `random-${Date.now()}` // Gerar ID aleat√≥rio para que cada mensagem seja tratada como de um usu√°rio diferente
      };
      console.log('Usando perfil aleat√≥rio para mensagem sem dados de usu√°rio:', user);
    }
      
      // Identificar messagems sequenciais do mesmo remetente EXCLUSIVAMENTE pelo ID
      // Se dois IDs de usu√°rio forem exatamente iguais, s√£o mensagens sequenciais do mesmo remetente
      const isFollowUp = {
        original: Boolean(user.id && lastSender.originalId && user.id === lastSender.originalId),
        translated: Boolean(user.id && lastSender.translatedId && user.id === lastSender.translatedId)
      };
      
      console.log(`‚ö†Ô∏è AGRUPAMENTO: Mensagem de ${user.name}:`);
      console.log(`‚ö†Ô∏è   - ID atual: '${user.id || 'vazio'}'`);
      console.log(`‚ö†Ô∏è   - √öltimo ID: '${lastSender.originalId || 'vazio'}'`); 
      console.log(`‚ö†Ô∏è   - √â sequencial? ${isFollowUp.original ? '‚úÖ SIM' : '‚ùå N√ÉO'}`);      

      // Atualizar o √∫ltimo remetente com o ID
      if (user.id) {
        lastSender.originalId = user.id;
        lastSender.translatedId = user.id;
        lastSender.original = user.name;
        lastSender.translated = user.name;
        console.log(`‚ÑπÔ∏è Rastreamento atualizado: ${user.name} (ID: ${user.id})`);
      } else {
        console.warn('‚ö†Ô∏è ID de usu√°rio ausente, agrupamento pode ser inconsistente');
      }

      // Formatar o timestamp
      const timeStr = formatTimestamp(timestamp);
      
      // Verificar se a mensagem cont√©m o nome do usu√°rio no formato "Username: message"
      // e remover a repeti√ß√£o se existir
      let cleanOriginal = original;
      let cleanTranslation = translation;
      
      // Padr√£o para detectar "Nome: mensagem"
      // Usamos uma abordagem mais flex√≠vel para n√£o depender da correspond√™ncia exata de nomes
      const usernamePattern = user.name ? new RegExp(`^${user.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}:\s*(.+)$`) : null;
      
      // Remover o prefixo de nome da mensagem original
      const originalMatch = cleanOriginal.match(usernamePattern);
      if (originalMatch) {
        cleanOriginal = originalMatch[1];
      }
      
      // Remover o prefixo de nome da mensagem traduzida
      const translationMatch = cleanTranslation.match(usernamePattern);
      if (translationMatch) {
        cleanTranslation = translationMatch[1];
      }
      
      // Criar elemento para avatar com fallback para iniciais se a imagem falhar
      const avatarStyle = user.avatar ? 
        `background-image: url('${user.avatar}')` : 
        `background-color: #4A154B; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold;`;
      
      const avatarContent = user.avatar ? '' : `<span>${(user.name || 'User').split(' ').map(part => part[0]).join('').substring(0, 2).toUpperCase()}</span>`;
      
      // Criar elemento para mensagem original no estilo Slack
      const origItem = document.createElement('div');
      origItem.className = 'message' + (sentByUser ? ' user-message' : '') + (isFollowUp.original ? ' follow-up' : '');
      origItem.innerHTML = `
        <div class="avatar" style="${avatarStyle}">${avatarContent}</div>
        <div class="message-content">
          <div class="message-header">
            <span class="username">${user.name}</span>
            <span class="timestamp">${timeStr}</span>
          </div>
          <div class="message-text">${cleanOriginal}</div>
        </div>
      `;
      
      // Criar elemento para mensagem traduzida no estilo Slack
      const transItem = document.createElement('div');
      transItem.className = 'message' + (sentByUser ? ' user-message' : '') + (isFollowUp.translated ? ' follow-up' : '');
      transItem.innerHTML = `
        <div class="avatar" style="${avatarStyle}">${avatarContent}</div>
        <div class="message-content">
          <div class="message-header">
            <span class="username">${user.name}</span>
            <span class="timestamp">${timeStr}</span>
          </div>
          <div class="message-text">${cleanTranslation}</div>
        </div>
      `;
      
      // Adicionar classes para anima√ß√£o de destaque para novas mensagens
      origItem.classList.add('new-message');
      transItem.classList.add('new-message');
      
      // Adicionar ao DOM
      origList.appendChild(origItem);
      transList.appendChild(transItem);
      
      // Scroll para mostrar as mensagens mais recentes
      origList.scrollTop = origList.scrollHeight;
      transList.scrollTop = transList.scrollHeight;
    }
    
    async function loadInitialMessages() {
      console.log('Carregando mensagens iniciais...');
      await ensureCurrentUserInfo();
      
      if (!myUserInfo.userId) {
        console.error('‚ùå ERRO GRAVE: N√£o foi poss√≠vel obter seu ID de usu√°rio. A identifica√ß√£o de mensagens pode estar incorreta!');
      } else {
        console.log('‚úÖ ID DO USU√ÅRIO CONFIRMADO antes de processar mensagens:', myUserInfo.userId);
      }
      
      // Resetar o estado da UI e buscar todas as mensagens
      document.getElementById('original-messages').innerHTML = '';
      document.getElementById('translated-messages').innerHTML = '';
      
      // Resetar o rastreamento do √∫ltimo remetente para evitar agrupamento incorreto
      lastSender = {
        originalId: null,
        translatedId: null,
        original: null,
        translated: null
      };
      
      try {
        const response = await fetch('/messages');
        const messages = await response.json();
        console.log('Mensagens carregadas:', messages);
        
        // Processar cada mensagem individualmente, garantindo que temos o ID do usu√°rio correto
        for (const msg of messages) {
          console.log('‚ùó Processando mensagem com informa√ß√µes de usu√°rio:', {
            user_id: msg.user_id || 'desconhecido',
            username: msg.username,
            seu_id: myUserInfo.userId || 'n√£o carregado'
          });
          
          // Adicionar a mensagem com as informa√ß√µes reais do usu√°rio
          addMessage(
            msg.original, 
            msg.translation, 
            false, // Valor ignorado - a compara√ß√£o √© feita com IDs
            msg.timestamp * 1000, // Converter para milissegundos
            {
              username: msg.username, 
              user_image: msg.user_image,
              user_id: msg.user_id,
              // N√£o usamos sent_by_me, comparamos IDs diretamente
            }
          );
        }
      } catch (error) {
        console.error('Erro ao carregar mensagens:', error);
      }
    }
    
    window.addEventListener('load', async function() {
      // Primeiro buscar as informa√ß√µes do usu√°rio autenticado
      console.log('Inicializando aplica√ß√£o SlackTranslator...');
      await fetchCurrentUserInfo();
      
      // Depois carregar as mensagens iniciais
      loadInitialMessages();
      
      setInterval(function() {
        fetch('/messages')
          .then(response => response.json())
          .then(messages => {
            if (origList.children.length !== messages.length) {
              loadInitialMessages();
            }
          })
          .catch(error => console.error('Erro ao atualizar mensagens:', error));
      }, 3000);
    });
  </script>
  <div style="margin-top: 20px; text-align: center;">
    <button id="test-button">Testar Mensagem</button>
    <p id="status-message" style="color: green; display: none;">Mensagem de teste enviada!</p>
  </div>
  
  <div id="message-form" style="margin-top: 30px; padding: 20px; background-color: #f5f5f5; border-radius: 8px;">
    <h3>Enviar mensagem para o Slack</h3>
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <textarea id="message-input" placeholder="Escreva sua mensagem em portugu√™s..." rows="4" style="padding: 8px; border-radius: 4px; border: 1px solid #ccc;"></textarea>
      <div style="display: flex; gap: 10px; justify-content: space-between;">
        <div style="flex-grow: 1; background-color: #eee; padding: 8px; border-radius: 4px; min-height: 50px;">
          <p style="margin: 0 0 5px 0; font-size: 0.8em; color: #666;">Visualiza√ß√£o da tradu√ß√£o:</p>
          <p id="translation-preview" style="margin: 0; font-style: italic;">A tradu√ß√£o aparecer√° aqui...</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px; justify-content: center;">
          <button id="translate-button" style="padding: 8px 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Traduzir</button>
          <button id="send-button" style="padding: 8px 16px; background-color: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;" disabled>Enviar</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.getElementById('test-button').addEventListener('click', function() {
      const statusEl = document.getElementById('status-message');
      statusEl.style.display = 'block';
      statusEl.textContent = 'Enviando mensagem de teste...';
      
      fetch('/test-message')
        .then(response => response.json())
        .then(data => {
          console.log('Teste enviado com sucesso:', data);
          statusEl.textContent = 'Mensagem de teste enviada!';
          
          // Adicionar a mensagem de teste usando as informa√ß√µes reais do usu√°rio
          // N√£o marcar como enviado pelo usu√°rio (false)
          // Isso permite que os dados do usu√°rio sejam exibidos corretamente
          console.log('Dados recebidos da API para mensagem de teste:', data);
          addMessage(data.original, data.translation, false, Date.now(), data);
          
          setTimeout(() => {
            statusEl.style.display = 'none';
          }, 3000);
        })
        .catch(error => {
          console.error('Erro ao enviar teste:', error);
          statusEl.textContent = 'Erro ao enviar mensagem de teste';
          statusEl.style.color = 'red';
        });
    });
    
    // C√≥digo para o formul√°rio de envio de mensagem
    const messageInput = document.getElementById('message-input');
    const translationPreview = document.getElementById('translation-preview');
    const translateButton = document.getElementById('translate-button');
    const sendButton = document.getElementById('send-button');
    
    let currentTranslation = null;
    
    // Fun√ß√£o para remover mensagens de rascunho
    function removeDraftMessages() {
      const draftMessages = document.querySelectorAll('.message.draft');
      draftMessages.forEach(msg => msg.remove());
    }
    
    // Fun√ß√£o para adicionar uma mensagem de rascunho (em processo de envio)
    function addDraftMessage(message, translation) {
      // Remover qualquer mensagem de rascunho anterior
      removeDraftMessages();
      
      // Obter seu nome e avatar se dispon√≠veis, ou usar valores padr√£o
      const username = myUserInfo.name || (userCache[myUserInfo.userId]?.name) || 'Voc√™';
      const avatar = myUserInfo.avatar || (userCache[myUserInfo.userId]?.avatar) || 'https://ui-avatars.com/api/?name=You';
      
      // Criar uma mensagem de rascunho nas duas colunas
      const msgElements = [
        { container: document.getElementById('original-messages'), content: message },
        { container: document.getElementById('translated-messages'), content: translation || 'Traduzindo...' }
      ];
      
      msgElements.forEach(({container, content}) => {
        const msgDiv = document.createElement('div');
        msgDiv.className = 'message draft';
        
        // Criar cabe√ßalho com autor e timestamp
        const msgHeader = document.createElement('div');
        msgHeader.className = 'message-header';
        
        // Avatar do usu√°rio
        const avatarImg = document.createElement('img');
        avatarImg.src = avatar;
        avatarImg.className = 'user-avatar';
        avatarImg.alt = username;
        
        // Nome do usu√°rio + indica√ß√£o que est√° sendo enviada
        const authorSpan = document.createElement('span');
        authorSpan.className = 'message-author';
        authorSpan.textContent = username + ' (enviando...)';
        
        // Timestamp atual
        const timeSpan = document.createElement('span');
        timeSpan.className = 'message-time';
        timeSpan.textContent = new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        
        // Conte√∫do da mensagem
        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.textContent = content;
        
        // Montar mensagem
        msgHeader.appendChild(avatarImg);
        msgHeader.appendChild(authorSpan);
        msgHeader.appendChild(timeSpan);
        msgDiv.appendChild(msgHeader);
        msgDiv.appendChild(contentDiv);
        
        // Adicionar ao container
        container.appendChild(msgDiv);
        container.scrollTop = container.scrollHeight;
      });
    }
    
    // Fun√ß√£o para traduzir o texto
    translateButton.addEventListener('click', function() {
      const messageText = messageInput.value.trim();
      
      if (!messageText) {
        translationPreview.textContent = 'Por favor, escreva uma mensagem primeiro.';
        translationPreview.style.color = 'red';
        return;
      }
      
      // Exibir mensagem sendo enviada
      addDraftMessage(messageText, 'Traduzindo...');
      
      translationPreview.textContent = 'Traduzindo...';
      translationPreview.style.color = '';
      sendButton.disabled = true;
      
      // Enviando o texto para tradu√ß√£o via API
      fetch('/translate-to-english', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ text: messageText })
      })
      .then(response => response.json())
      .then(data => {
        if (data.translation) {
          translationPreview.textContent = data.translation;
          currentTranslation = data.translation;
          sendButton.disabled = false;
          
          // Atualizar a mensagem de rascunho com a tradu√ß√£o
          addDraftMessage(messageText, data.translation);
        } else {
          translationPreview.textContent = 'Erro ao traduzir: ' + (data.error || 'Erro desconhecido');
          translationPreview.style.color = 'red';
          sendButton.disabled = true;
        }
      })
      .catch(error => {
        console.error('Erro na tradu√ß√£o:', error);
        translationPreview.textContent = 'Erro ao traduzir. Tente novamente.';
        translationPreview.style.color = 'red';
        sendButton.disabled = true;
        
        // Remover mensagem de rascunho em caso de erro
        removeDraftMessages();
      });
    });
    
    // Fun√ß√£o para enviar a mensagem traduzida
    sendButton.addEventListener('click', function() {
      if (!currentTranslation) {
        return;
      }
      
      sendButton.disabled = true;
      sendButton.textContent = 'Enviando...';
      
      // Enviando a mensagem traduzida para o Slack
      fetch('/send-to-slack', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          original: messageInput.value.trim(),
          translation: currentTranslation
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Remover a mensagem de rascunho e esperar a atualiza√ß√£o do servidor
          removeDraftMessages();
          console.log('Mensagem enviada com sucesso, aguardando atualiza√ß√£o do servidor...');
          
          // Limpar o formul√°rio ap√≥s envio bem-sucedido
          messageInput.value = '';
          translationPreview.textContent = 'Mensagem enviada com sucesso!';
          translationPreview.style.color = 'green';
          currentTranslation = null;
          
          // For√ßar uma atualiza√ß√£o imediata das mensagens
          setTimeout(() => loadInitialMessages(), 500);
          
          setTimeout(() => {
            translationPreview.textContent = 'A tradu√ß√£o aparecer√° aqui...';
            translationPreview.style.color = '';
          }, 3000);
        } else {
          translationPreview.textContent = 'Erro ao enviar: ' + (data.error || 'Erro desconhecido');
          translationPreview.style.color = 'red';
          sendButton.disabled = false;
        }
      })
      .catch(error => {
        console.error('Erro ao enviar mensagem:', error);
        translationPreview.textContent = 'Erro ao enviar. Tente novamente.';
        translationPreview.style.color = 'red';
        sendButton.disabled = false;
      })
      .finally(() => {
        sendButton.textContent = 'Enviar';
      });
    });
    
    // Desabilitar bot√£o de envio quando o texto for alterado
    messageInput.addEventListener('input', function() {
      sendButton.disabled = true;
      if (messageInput.value.trim()) {
        translationPreview.textContent = 'Clique em "Traduzir" para ver a pr√©via da tradu√ß√£o.';
        translationPreview.style.color = '';
      } else {
        translationPreview.textContent = 'A tradu√ß√£o aparecer√° aqui...';
        translationPreview.style.color = '';
      }
    });
  </script>
</body>
</html>
